//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.5448
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Xml.Serialization;
using FlatRedBall;
using System;
using Microsoft.Xna.Framework.Graphics;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using FlatRedBall.IO;
using FlatRedBall.Content;
using FlatRedBall.Content.Scene;

// 
// This source code was auto-generated by xsd, Version=2.0.50727.3038.
// 
namespace TiledMap
{

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(ElementName = "map", Namespace = "", IsNullable = false)]
    public partial class TiledMapSave
    {
        enum LessOrGreaterDesired
        {
            Less,
            Greater
        }

        public Scene ToScene(string contentManagerName)
        {
            SpriteEditorScene scene = ToSpriteEditorScene();
            return scene.ToScene(contentManagerName);
        }

        public SpriteEditorScene ToSpriteEditorScene()
        {
            SpriteEditorScene toReturn = new SpriteEditorScene();

            // TODO: Somehow add all layers separately

            int layercount = 0;
            foreach (mapLayer layer in this.layer)
            {
                int count = 0;
                foreach (int gid in layer.data[0].tiles)
                {
                    SpriteSave sprite = new SpriteSave();
                    mapTileset tileSet = getTilesetForGid(gid);
                    if (tileSet == null)
                    {
                        ++count;
                        continue;
                    }

                    int imageWidth = tileSet.image[0].width;
                    int imageHeight = tileSet.image[0].height;
                    int tileWidth = tileSet.tilewidth;
                    int spacing = tileSet.spacing;
                    int tileHeight = tileSet.tileheight;
                    int margin = tileSet.margin;

                    // TODO: only calculate these once per tileset. Perhaps it can be done in the deserialize method
                    int tilesWide = (imageWidth - margin) / (tileWidth + spacing);
                    int tilesHigh = (imageHeight - margin) / (tileHeight + spacing);


                    sprite.Texture = tileSet.image[0].source;

                    // Calculate pixel coordinates in the texture sheet
                    int leftPixelCoord = TiledMapSave.calculateXCoordinate(gid - tileSet.firstgid, imageWidth, tileWidth, spacing, margin);
                    int topPixelCoord = TiledMapSave.calculateYCoordinate(gid - tileSet.firstgid, imageWidth, tileWidth, tileHeight, spacing, margin);
                    int rightPixelCoord = leftPixelCoord + tileWidth;
                    int bottomPixelCoord = topPixelCoord + tileHeight;

                    // Calculate relative texture coordinates based on pixel coordinates
                    sprite.TopTextureCoordinate = GetTextureCoordinate(topPixelCoord, imageHeight, LessOrGreaterDesired.Greater);
                    sprite.LeftTextureCoordinate = GetTextureCoordinate(leftPixelCoord, imageWidth, LessOrGreaterDesired.Greater);

                    sprite.RightTextureCoordinate = GetTextureCoordinate(rightPixelCoord, imageWidth, LessOrGreaterDesired.Less);
                    sprite.BottomTextureCoordinate = GetTextureCoordinate(bottomPixelCoord, imageHeight, LessOrGreaterDesired.Less);

                    // Now calculate the world coordinates
                    int normalizedX = count % this.width;
                    int normalizedY = count / this.width;

                    if (this.orientation == null || this.orientation.Equals("orthogonal"))
                    {
                        sprite.X = (normalizedX * tileWidth);
                        sprite.Y = -(normalizedY * tileHeight);
                    }
                    else if (this.orientation != null && this.orientation.Equals("isometric"))
                    {
           
                        sprite.Y = -(float)((normalizedX * this.tilewidth / 2.0f) + (normalizedY * this.tilewidth / 2.0f)) / 2;
                        sprite.X = -(float)(((normalizedY * this.tilewidth / 2.0f) - (normalizedX * this.tileheight / 2.0f) * 2));
                    }
                    ++count;
                    sprite.ScaleX = tileWidth / 2;
                    sprite.ScaleY = tileHeight / 2;

                    sprite.Z = layercount;

                    toReturn.SpriteList.Add(sprite);
                   
                }
                ++layercount;
            }

            return toReturn;
        }

        private mapTileset getTilesetForGid(int gid)
        {
            // Assuming tilesets are sorted by the firstgid value...
            // Resort with LINQ if not
            for (int i = tileset.Length - 1; i >= 0; --i)
            {
                mapTileset tileSet = tileset[i];
                if (gid >= tileSet.firstgid)
                {
                    return tileSet;
                }
            }
            return null;
        }

        private float GetTextureCoordinate(int pixelCoord, int dimension, LessOrGreaterDesired lessOrGreaterDesired)
        {
            float asFloat = pixelCoord / (float)dimension;

            //const float modValue = .000001f;
            const float modValue = .0000002f;
            //const float modValue = .00001f;
            if (lessOrGreaterDesired == LessOrGreaterDesired.Greater)
            {
                return asFloat + modValue;
            }
            else
            {
                return asFloat - modValue;
            }
        }

        private static int calculateYCoordinate(int gid, int imageWidth, int tileWidth, int tileHeight, int spacing, int margin)
        {
            int tilesWide = (imageWidth - margin) / (tileWidth + spacing);
            int normalizedy = gid / tilesWide;
            int pixely = normalizedy * (tileHeight + spacing) + margin;

            return pixely;
        }

        private static int calculateXCoordinate(int gid, int imageWidth, int tileWidth, int spacing, int margin)
        {
            int tilesWide = (imageWidth - margin) / (tileWidth + spacing);
            int normalizedX = gid % tilesWide;
            int pixelX = normalizedX * (tileWidth + spacing) + margin;

            return pixelX;
        }

        public static TiledMapSave FromFile(string fileName)
        {
            string oldRelativeDirectory = FileManager.RelativeDirectory;
            FileManager.RelativeDirectory = FileManager.GetDirectory(fileName);
            TiledMapSave tms = FileManager.XmlDeserialize<TiledMapSave>(fileName);
            FileManager.RelativeDirectory = oldRelativeDirectory;
            return tms;
        }

        private mapTileset[] tilesetField;

        private mapLayer[] layerField;

        private string versionField;

        private string orientationField;

        private int widthField;

        private int heightField;

        private int tilewidthField;

        private int tileheightField;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("tileset", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public mapTileset[] tileset
        {
            get
            {
                return this.tilesetField;
            }
            set
            {
                this.tilesetField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("layer", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public mapLayer[] layer
        {
            get
            {
                return this.layerField;
            }
            set
            {
                this.layerField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string version
        {
            get
            {
                return this.versionField;
            }
            set
            {
                this.versionField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string orientation
        {
            get
            {
                return this.orientationField;
            }
            set
            {
                this.orientationField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int width
        {
            get
            {
                return this.widthField;
            }
            set
            {
                this.widthField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int height
        {
            get
            {
                return this.heightField;
            }
            set
            {
                this.heightField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int tilewidth
        {
            get
            {
                return this.tilewidthField;
            }
            set
            {
                this.tilewidthField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int tileheight
        {
            get
            {
                return this.tileheightField;
            }
            set
            {
                this.tileheightField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapTileset
    {

        private mapTilesetImage[] imageField;

        private int firstgidField;

        private string nameField;

        private int tilewidthField;

        private int tileheightField;

        private int spacingField;

        private int marginField;

        private string sourceField;

        [System.Xml.Serialization.XmlAttributeAttribute("source", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string source
        {
            get
            {
                return sourceField;
            }
            set
            {
                this.sourceField = value;
                tileset xts = FileManager.XmlDeserialize<tileset>(sourceField);
                image = new mapTilesetImage[xts.image.Length];
                int count = 0;
                foreach (tilesetImage ximage in xts.image)
                {
                    this.image[count] = new mapTilesetImage();
                    this.image[count].source = xts.image[count].source;
                    this.image[count].height = xts.image[count].height;
                    this.image[count].width = xts.image[count].width;

                    count++;
                }

                this.name = xts.name;
                this.margin = xts.margin;
                this.spacing = xts.spacing;
                this.tileheight = xts.tileheight;
                this.tilewidth = xts.tilewidth;
            }
        }


        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("image", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public mapTilesetImage[] image
        {
            get
            {
                return this.imageField;
            }
            set
            {
                if (this.imageField != null && this.imageField.Length > 0)
                {
                    return;
                }
                else
                {
                    this.imageField = value;
                }
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int firstgid
        {
            get
            {
                return this.firstgidField;
            }
            set
            {
                this.firstgidField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int tilewidth
        {
            get
            {
                return this.tilewidthField;
            }
            set
            {
                this.tilewidthField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int tileheight
        {
            get
            {
                return this.tileheightField;
            }
            set
            {
                this.tileheightField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int spacing
        {
            get
            {
                return this.spacingField;
            }
            set
            {
                this.spacingField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int margin
        {
            get
            {
                return this.marginField;
            }
            set
            {
                this.marginField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapTilesetImage
    {
        
        private string sourceField;

        private int widthField;

        private int heightField;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string source
        {
            get
            {
                return this.sourceField;
            }
            set
            {
                this.sourceField = value;
                if (this.sourceField != null)
                {
                    this.sourceField = this.sourceField.Replace("/", "\\");
                }
            }
        }

        [XmlIgnore]
        public string sourceFileName
        {
            get
            {
                if (!string.IsNullOrEmpty(source) && source.Contains("\\"))
                {
                    return source.Substring(source.LastIndexOf('\\') + 1);
                }
                else
                {
                    return source;
                }
            }
        }

        [XmlIgnore]
        public string sourceDirectory
        {
            get
            {
                if (!string.IsNullOrEmpty(source) && source.Contains("\\"))
                {
                    return source.Substring(0, source.LastIndexOf('\\'));
                }
                else
                {
                    return source;
                }
            }
        }


        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int width
        {
            get
            {
                return this.widthField;
            }
            set
            {
                this.widthField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int height
        {
            get
            {
                return this.heightField;
            }
            set
            {
                this.heightField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapLayer
    {

        private mapLayerData[] dataField;

        private string nameField;

        private int widthField;

        private int heightField;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("data", Form = System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable = true)]
        public mapLayerData[] data
        {
            get
            {
                return this.dataField;
            }
            set
            {
                this.dataField = value;
                if (dataField != null)
                {
                    foreach (mapLayerData layerData in dataField)
                    {
                        layerData.length = width * height;
                    }
                }
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int width
        {
            get
            {
                return this.widthField;
            }
            set
            {
                this.widthField = value;
                if (this.data != null)
                {
                    foreach (mapLayerData layerData in data)
                    {
                        layerData.length = width * height;
                    }
                }
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int height
        {
            get
            {
                return this.heightField;
            }
            set
            {
                this.heightField = value;
                if (this.data != null)
                {
                    foreach (mapLayerData layerData in data)
                    {
                        layerData.length = width * height;
                    }
                }
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapLayerData
    {

        private string encodingField;

        private string compressionField;

        private string valueField;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string encoding
        {
            get
            {
                return this.encodingField;
            }
            set
            {
                this.encodingField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string compression
        {
            get
            {
                return this.compressionField;
            }
            set
            {
                this.compressionField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string Value
        {
            get
            {
                return this.valueField;
            }
            set
            {
                this.valueField = value;
            }
        }

        private List<uint> _ids = null;
        [XmlIgnore]
        public List<uint> tiles
        {
            get
            {
                if (encodingField != "base64")
                {
                    throw new NotImplementedException("Tiled Map must be saved with base64 encoding");
                }

                if (_ids == null)
                {
                    _ids = new List<uint>(length);
                    // get a stream to the decoded Base64 text
                    Stream data = new MemoryStream(Convert.FromBase64String(Value.Trim()), false);
                    switch (compression)
                    {
                        case "gzip":
                            data = new GZipStream(data, CompressionMode.Decompress, false);
                            break;
                        case "zlib":
                            data = new Ionic.Zlib.ZlibStream(data, Ionic.Zlib.CompressionMode.Decompress, false);
                            break;
                        case null:
                            // Not compressed. Data is already decoded.
                            break;
                        default:
                            throw new InvalidOperationException("Unknown compression: " + compression);
                    }

                    // simply read in all the integers
                    using (data)
                    {
                        using (BinaryReader reader = new BinaryReader(data))
                        {
                            _ids = new List<uint>();
                            for (int i = 0; i < length; i++)
                            {
                                _ids.Add(reader.ReadUInt32());
                            }
                        }
                    }
                }

                return _ids;
            }

        }

        public int length { get; set; }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public partial class NewDataSet
    {

        private TiledMapSave[] itemsField;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("map")]
        public TiledMapSave[] Items
        {
            get
            {
                return this.itemsField;
            }
            set
            {
                this.itemsField = value;
            }
        }
    }
}