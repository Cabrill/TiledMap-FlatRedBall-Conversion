//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.5448
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Xml.Serialization;
using FlatRedBall;
using System;
using Microsoft.Xna.Framework.Graphics;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using FlatRedBall.IO;
using FlatRedBall.Content;
using FlatRedBall.Content.Scene;
using FlatRedBall.Content.AI.Pathfinding;
using FlatRedBall.AI.Pathfinding;
using FlatRedBall.Content.Math.Geometry;
using FlatRedBall.Content.Polygon;
using FlatRedBall.Math.Geometry;
using System.Text;

// 
// This source code was auto-generated by xsd, Version=2.0.50727.3038.
// 
namespace TiledMap
{

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(ElementName = "map", Namespace = "", IsNullable = false)]
    public partial class TiledMapSave
    {
        enum LessOrGreaterDesired
        {
            Less,
            Greater,
            NoChange
        }

        public Scene ToScene(string contentManagerName)
        {
            SpriteEditorScene scene = ToSpriteEditorScene();
            return scene.ToScene(contentManagerName);
        }

        public ShapeCollectionSave ToShapeCollectionSave()
        {
            return ToShapeCollectionSave(null);
        }

        public ShapeCollection ToShapeCollection()
        {
            return ToShapeCollectionSave().ToShapeCollection();
        }

        public ShapeCollection ToShapeCollection(string layerName)
        {
            ShapeCollectionSave scs = ToShapeCollectionSave(layerName);
            
            return scs.ToShapeCollection();
        }

        public ShapeCollectionSave ToShapeCollectionSave(string layerName)
        {
            ShapeCollectionSave shapes = new ShapeCollectionSave();


            if (this.objectgroup == null || this.objectgroup.Length == 0)
            {
                return shapes;
            }

            foreach (mapObjectgroup group in this.objectgroup)
            {
                if (group.@object != null && !string.IsNullOrEmpty(group.name) && (string.IsNullOrEmpty(layerName) || group.name.Equals(layerName)))
                {
                    foreach (mapObjectgroupObject @object in group.@object)
                    {
                        if (@object.polygon != null)
                        {
                            foreach (mapObjectgroupObjectPolygon polygon in @object.polygon)
                            {
                                PolygonSave p = convertTMXObjectToFRBPolygonSave(group.width, group.height,
                                    @object.x, @object.y, polygon.points, true);
                                if (p != null)
                                {
                                    shapes.PolygonSaves.Add(p);
                                }
                            }
                        }

                        if (@object.polyline != null)
                        {
                            foreach (mapObjectgroupObjectPolyline polyline in @object.polyline)
                            {
                                PolygonSave p = convertTMXObjectToFRBPolygonSave(group.width, group.height,
                                    @object.x, @object.y, polyline.points, false);
                                if (p != null)
                                {
                                    shapes.PolygonSaves.Add(p);
                                }
                            }
                        }

                        if (@object.polygon == null && @object.polyline == null)
                        {
                            PolygonSave p = convertTMXObjectToFRBPolygonSave(group.width, group.height, @object.x, @object.y, @object.width, @object.height);
                            if (p != null)
                            {
                                shapes.PolygonSaves.Add(p);
                            }
                        }
                    }
                }
            }
            return shapes;
        }

        private PolygonSave convertTMXObjectToFRBPolygonSave(int groupWidth, int groupHeight, int x, int y, int width, int height)
        {
            StringBuilder pointsSB = new StringBuilder();

            pointsSB.Append("0,0");

            pointsSB.AppendFormat(" {0},{1}", width, 0);
            pointsSB.AppendFormat(" {0},{1}", width, height);
            pointsSB.AppendFormat(" {0},{1}", 0, height);
           

            return convertTMXObjectToFRBPolygonSave(groupWidth, groupHeight, x, y, pointsSB.ToString(), true);
        }

        private PolygonSave convertTMXObjectToFRBPolygonSave(int width, int height, int x, int y, string points, bool connectBackToStart)
        {
            if (string.IsNullOrEmpty(points))
            {
                return null;
            }
            PolygonSave polygon = new PolygonSave();
            string[] pointString = points.Split(" ".ToCharArray());
            float z;
            float newx;
            float newy;
            float fx = x;
            float fy = y;

            if ("orthogonal".Equals(this.orientation))
            {
                fx -= tilewidth / 2.0f;
                fy -= tileheight / 2.0f;
            }
            else if ("isometric".Equals(this.orientation))
            {
                fx -= tilewidth / 4.0f;
                fy -= tileheight / 2.0f;
            }
            
            calculateWorldCoordinates(0, fx / (float)tileheight, fy / (float)tileheight, this.tilewidth, this.tileheight, width * tilewidth, out newx, out newy, out z);
            polygon.X = newx - tilewidth / 2.0f;
            polygon.Y = newy - tileheight / 2.0f;
            Point[] pointsArr = new Point[pointString.Length + (connectBackToStart ? 1 : 0)];

            int count = 0;
            foreach (string pointStr in pointString)
            {
                string[] xy = pointStr.Split(",".ToCharArray());
                int relativeX = Convert.ToInt32(xy[0]);
                int relativeY = Convert.ToInt32(xy[1]);

                float normalizedX = relativeX / (float)tileheight;
                float normalizedY = relativeY / (float)tileheight;

                calculateWorldCoordinates(0, normalizedX, normalizedY, this.tilewidth, this.tileheight, width * tilewidth, out newx, out newy, out z);

                pointsArr[count].X = newx;
                pointsArr[count].Y = newy;
              

                
                ++count;
            }

            if (connectBackToStart)
            {
                string[] xy = pointString[0].Split(",".ToCharArray());
                int relativeX = Convert.ToInt32(xy[0]);
                int relativeY = Convert.ToInt32(xy[1]);

                float normalizedX = relativeX / (float)tileheight;
                float normalizedY = relativeY / (float)tileheight;

                calculateWorldCoordinates(0, normalizedX, normalizedY, this.tilewidth, this.tileheight, width * tilewidth, out newx, out newy, out z);

                pointsArr[count].X = newx;
                pointsArr[count].Y = newy;                
            }
            polygon.Points = pointsArr;

            return polygon;
        }

       

        public NodeNetwork ToNodeNetwork()
        {
            return ToNodeNetwork(true, true, true);
        }

        public NodeNetworkSave ToNodeNetworkSave(bool linkHorizontally, bool linkVertically, bool linkDiagonally)
        {
            NodeNetwork nodeNetwork = ToNodeNetwork(linkHorizontally, linkVertically, linkDiagonally);
            return NodeNetworkSave.FromNodeNetwork(nodeNetwork);
        }

    
        public NodeNetworkSave ToNodeNetworkSave()
        {
            return ToNodeNetworkSave(true, true, true);
        }
    
        public NodeNetwork ToNodeNetwork(bool linkHorizontally, bool linkVertically, bool linkDiagonally)
        {
            NodeNetwork toReturn = new NodeNetwork();


            int layercount = 0;
            foreach (mapLayer layer in this.layer)
            {
                Dictionary<int, Dictionary<int, Dictionary<int, PositionedNode>>> allNodes = new Dictionary<int, Dictionary<int, Dictionary<int, PositionedNode>>>();
                allNodes[layercount] = new Dictionary<int, Dictionary<int, PositionedNode>>();
                int count = 0;
                foreach (int gid in layer.data[0].tiles)
                {
                    
                    mapTileset tileSet = getTilesetForGid(gid);
                    if (tileSet == null)
                    {
                        ++count;
                        continue;
                    }

                    PositionedNode node = new PositionedNode();

                    int tileWidth = tileSet.tilewidth;
                    int tileHeight = tileSet.tileheight;
                    int X = count % this.width;
                    int Y = count / this.width;

                    float nodex;
                    float nodey;
                    float nodez;

                    calculateWorldCoordinates(layercount, count, tilewidth, tileheight, layer.width, out nodex, out nodey, out nodez);

                    node.X = nodex;
                    node.Y = nodey;
                    node.Z = nodez;

                    if (!allNodes[layercount].ContainsKey(X))
                    {
                        allNodes[layercount][X] = new Dictionary<int, PositionedNode>();
                    }

                    allNodes[layercount][X][Y] = node;
                    node.Name = string.Format("Node {0}", count);
                    toReturn.AddNode(node);
                    ++count;
                }
                setupNodeLinks(linkHorizontally, linkVertically, linkDiagonally, allNodes[layercount]);

                removeExcludedNodesViaPolygonLayer(toReturn, layer, allNodes[layercount]);
                lowerNodesInNodesDownShapeCollection(layer, allNodes[layercount]);
                raiseNodesInNodesUpShapeCollection(layer, allNodes[layercount]);

                ++layercount;
            }
            toReturn.UpdateShapes();

            return toReturn;
        }

        private void raiseNodesInNodesUpShapeCollection(mapLayer layer, Dictionary<int, Dictionary<int, PositionedNode>> allNodes)
        {
            ShapeCollection sc = this.ToShapeCollection(layer.name + " nodesup");
            List<PositionedNode> nodesToMoveUp = getNodesThatCollideWithShapeCollection(sc, allNodes);

            foreach (PositionedNode node in nodesToMoveUp)
            {
                node.Z += .001f;
            }
        }

        private void lowerNodesInNodesDownShapeCollection(mapLayer layer, Dictionary<int, Dictionary<int, PositionedNode>> allNodes)
        {
            ShapeCollection sc = this.ToShapeCollection(layer.name + " nodesdown");
            List<PositionedNode> nodesToMoveDown = getNodesThatCollideWithShapeCollection(sc, allNodes);

            foreach (PositionedNode node in nodesToMoveDown)
            {
                node.Z -= .001f;
            }
        }

        private void removeExcludedNodesViaPolygonLayer(NodeNetwork nodeNetwork, mapLayer layer, Dictionary<int, Dictionary<int, PositionedNode>> allNodes)
        {
            ShapeCollection sc = this.ToShapeCollection(layer.name + " nonodes");
            List<PositionedNode> nodesToRemove = getNodesThatCollideWithShapeCollection(sc, allNodes);

            foreach (PositionedNode node in nodesToRemove)
            {
                nodeNetwork.Remove(node);
            }
        }

        private List<PositionedNode> getNodesThatCollideWithShapeCollection(ShapeCollection sc, Dictionary<int, Dictionary<int, PositionedNode>> allNodes)
        {
            List<PositionedNode> returnValue = new List<PositionedNode>();

            if (sc != null && sc.Polygons != null)
            {
                foreach (Polygon polygon in sc.Polygons)
                {
                    polygon.ForceUpdateDependencies();
                }

                foreach (KeyValuePair<int, Dictionary<int, PositionedNode>> xpair in allNodes)
                {
                    int x = xpair.Key;
                    foreach (KeyValuePair<int, PositionedNode> ypair in xpair.Value)
                    {
                        PositionedNode node = ypair.Value;
                        AxisAlignedRectangle rectangle = new AxisAlignedRectangle();
                        rectangle.Position = node.Position;
                        rectangle.ScaleX = 1;
                        rectangle.ScaleY = 1;

                        if (sc.CollideAgainst(rectangle))
                        {
                            returnValue.Add(node);
                        }
                    }
                }
            }
            return returnValue;
        }

        private static void setupNodeLinks(bool linkHorizontally, bool linkVertically, bool linkDiagonally, Dictionary<int, Dictionary<int, PositionedNode>> allNodes)
        {
            foreach (KeyValuePair<int, Dictionary<int, PositionedNode>> xpair in allNodes)
            {
                int x = xpair.Key;
                foreach (KeyValuePair<int, PositionedNode> ypair in xpair.Value)
                {
                    int y = ypair.Key;

                    if (linkVertically && allNodes.ContainsKey(x - 1) && allNodes[x - 1].ContainsKey(y))
                    {
                        ypair.Value.LinkTo(allNodes[x - 1][y]);
                    }
                    if (linkHorizontally && xpair.Value.ContainsKey(y - 1))
                    {
                        ypair.Value.LinkTo(xpair.Value[y - 1]);
                    }
                    if (linkDiagonally && allNodes.ContainsKey(x - 1) && allNodes[x - 1].ContainsKey(y - 1))
                    {
                        ypair.Value.LinkTo(allNodes[x - 1][y - 1]);
                    }
                    if (linkDiagonally && allNodes.ContainsKey(x + 1) && allNodes[x + 1].ContainsKey(y - 1))
                    {
                        ypair.Value.LinkTo(allNodes[x + 1][y - 1]);
                    }
                }
            }
        }

        public SpriteEditorScene ToSpriteEditorScene()
        {
            SpriteEditorScene toReturn = new SpriteEditorScene();
            toReturn.CoordinateSystem = FlatRedBall.Math.CoordinateSystem.RightHanded;

            // TODO: Somehow add all layers separately

            int layercount = 0;
            foreach (mapLayer layer in this.layer)
            {
                int count = 0;
                foreach (int gid in layer.data[0].tiles)
                {
                    mapTileset tileSet = getTilesetForGid(gid);
                    if (tileSet == null)
                    {
                        ++count;
                        continue;
                    }
                    
                    SpriteSave sprite = new SpriteSave();
                    int imageWidth = tileSet.image[0].width;
                    int imageHeight = tileSet.image[0].height;
                    int tileWidth = tileSet.tilewidth;
                    int spacing = tileSet.spacing;
                    int tileHeight = tileSet.tileheight;
                    int margin = tileSet.margin;

                    // TODO: only calculate these once per tileset. Perhaps it can be done in the deserialize method
                    int tilesWide = (imageWidth - margin) / (tileWidth + spacing);
                    int tilesHigh = (imageHeight - margin) / (tileHeight + spacing);


                    sprite.Texture = tileSet.image[0].source;

                    setSpriteTextureCoordinates(gid, sprite, tileSet, imageWidth, imageHeight, tileWidth, spacing, tileHeight, margin);
                    calculateWorldCoordinates(layercount, count, tileWidth, tileHeight, this.width, out sprite.X, out sprite.Y, out sprite.Z);

                    ++count;
                    sprite.ScaleX = tileWidth / 2;
                    sprite.ScaleY = tileHeight / 2;

                    if (tileSet.tileoffset != null && tileSet.tileoffset.Length == 1)
                    {
                        sprite.X += tileSet.tileoffset[0].x;
                        sprite.Y -= tileSet.tileoffset[0].y;
                    }


                    toReturn.SpriteList.Add(sprite);
                   
                }
                ++layercount;
            }

            return toReturn;
        }

        private void calculateWorldCoordinates(int layercount, int count, int tileWidth, int tileHeight, int layerWidth, out float x, out float y, out float z)
        {
            int normalizedX = count % this.width;
            int normalizedY = count / this.width;
            calculateWorldCoordinates(layercount, normalizedX, normalizedY, tileWidth, tileHeight, layerWidth, out x, out y, out z);
        }

        private void calculateWorldCoordinates(int layercount, float normalizedX, float normalizedY, int tileWidth, int tileHeight, int layerWidth, out float x, out float y, out float z)
        {
            if (this.orientation == null || this.orientation.Equals("orthogonal"))
            {
                x = (normalizedX * tileWidth);
                y = -(normalizedY * tileHeight);
                z = layercount;

            }
            else if (this.orientation != null && this.orientation.Equals("isometric"))
            {
                y = -(float)((normalizedX * this.tilewidth / 2.0f) + (normalizedY * this.tilewidth / 2.0f)) / 2;
                y += tileHeight / 2.0f;
                x = -(float)(((normalizedY * this.tilewidth / 2.0f) - (normalizedX * this.tileheight / 2.0f) * 2));
                x += tileWidth / 2.0f;
                z = ((normalizedY * layerWidth + normalizedX) * .000001f) + layercount;
            }
            else
            {
                throw new NotImplementedException("Unknown orientation type");
            }
        }

        private void setSpriteTextureCoordinates(int gid, SpriteSave sprite, mapTileset tileSet, int imageWidth, int imageHeight, int tileWidth, int spacing, int tileHeight, int margin)
        {
            // Calculate pixel coordinates in the texture sheet
            int leftPixelCoord = TiledMapSave.calculateXCoordinate(gid - tileSet.firstgid, imageWidth, tileWidth, spacing, margin);
            int topPixelCoord = TiledMapSave.calculateYCoordinate(gid - tileSet.firstgid, imageWidth, tileWidth, tileHeight, spacing, margin);
            int rightPixelCoord = leftPixelCoord + tileWidth;
            int bottomPixelCoord = topPixelCoord + tileHeight;

            // Calculate relative texture coordinates based on pixel coordinates
            LessOrGreaterDesired changeVal = LessOrGreaterDesired.Greater;

            if (this.orientation != null && this.orientation.Equals("isometric"))
            {
                changeVal = LessOrGreaterDesired.NoChange;
            }

            sprite.TopTextureCoordinate = GetTextureCoordinate(topPixelCoord, imageHeight, changeVal);
            sprite.LeftTextureCoordinate = GetTextureCoordinate(leftPixelCoord, imageWidth, changeVal);

            changeVal = LessOrGreaterDesired.Less;
            if (this.orientation != null && this.orientation.Equals("isometric"))
            {
                changeVal = LessOrGreaterDesired.NoChange;
            }

            sprite.RightTextureCoordinate = GetTextureCoordinate(rightPixelCoord, imageWidth, changeVal);
            sprite.BottomTextureCoordinate = GetTextureCoordinate(bottomPixelCoord, imageHeight, changeVal);
        }

        private mapTileset getTilesetForGid(int gid)
        {
            // Assuming tilesets are sorted by the firstgid value...
            // Resort with LINQ if not
            for (int i = tileset.Length - 1; i >= 0; --i)
            {
                mapTileset tileSet = tileset[i];
                if (gid >= tileSet.firstgid)
                {
                    return tileSet;
                }
            }
            return null;
        }

        private float GetTextureCoordinate(int pixelCoord, int dimension, LessOrGreaterDesired lessOrGreaterDesired)
        {
            float asFloat = pixelCoord / (float)dimension;

            //const float modValue = .000001f;
            const float modValue = .000002f;
            //const float modValue = .00001f;
            if (lessOrGreaterDesired == LessOrGreaterDesired.Greater)
            {
                return asFloat + modValue;
            }
            else if (lessOrGreaterDesired == LessOrGreaterDesired.Less)
            {
                return asFloat - modValue;
            }
            else
            {
                return asFloat;
            }
        }

        private static int calculateYCoordinate(int gid, int imageWidth, int tileWidth, int tileHeight, int spacing, int margin)
        {
            int tilesWide = (imageWidth - margin) / (tileWidth + spacing);
            int normalizedy = gid / tilesWide;
            int pixely = normalizedy * (tileHeight + spacing) + margin;

            return pixely;
        }

        private static int calculateXCoordinate(int gid, int imageWidth, int tileWidth, int spacing, int margin)
        {
            int tilesWide = (imageWidth - margin) / (tileWidth + spacing);
            int normalizedX = gid % tilesWide;
            int pixelX = normalizedX * (tileWidth + spacing) + margin;

            return pixelX;
        }

        public static TiledMapSave FromFile(string fileName)
        {
            string oldRelativeDirectory = FileManager.RelativeDirectory;
            try
            {
                FileManager.RelativeDirectory = FileManager.GetDirectory(fileName);
            }
            catch (Exception)
            {
            }
            TiledMapSave tms = FileManager.XmlDeserialize<TiledMapSave>(fileName);
            FileManager.RelativeDirectory = oldRelativeDirectory;
            return tms;
        }

        private mapTileset[] tilesetField;

        private mapLayer[] layerField;

        private string versionField;

        private string orientationField;

        private int widthField;

        private int heightField;

        private int tilewidthField;

        private int tileheightField;

        private mapObjectgroup[] objectgroupField;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("tileset", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public mapTileset[] tileset
        {
            get
            {
                return this.tilesetField;
            }
            set
            {
                this.tilesetField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("layer", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public mapLayer[] layer
        {
            get
            {
                return this.layerField;
            }
            set
            {
                this.layerField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("objectgroup", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public mapObjectgroup[] objectgroup
        {
            get
            {
                return this.objectgroupField;
            }
            set
            {
                this.objectgroupField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string version
        {
            get
            {
                return this.versionField;
            }
            set
            {
                this.versionField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string orientation
        {
            get
            {
                return this.orientationField;
            }
            set
            {
                this.orientationField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int width
        {
            get
            {
                return this.widthField;
            }
            set
            {
                this.widthField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int height
        {
            get
            {
                return this.heightField;
            }
            set
            {
                this.heightField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int tilewidth
        {
            get
            {
                return this.tilewidthField;
            }
            set
            {
                this.tilewidthField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int tileheight
        {
            get
            {
                return this.tileheightField;
            }
            set
            {
                this.tileheightField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapTileset
    {

        private mapTilesetImage[] imageField;

        private mapTilesetTileOffset[] tileOffsetField;

        private int firstgidField;

        private string nameField;

        private int tilewidthField;

        private int tileheightField;

        private int spacingField;

        private int marginField;

        private string sourceField;

        [XmlIgnore]
        public string SourceDirectory
        {
            get
            {
                if (sourceField != null && sourceField.Contains("\\"))
                {
                    return sourceField.Substring(0, sourceField.LastIndexOf('\\'));
                }
                else
                {
                    return ".";
                }
            }
        }

        [System.Xml.Serialization.XmlAttributeAttribute("source", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string source
        {
            get
            {
                return sourceField;
            }
            set
            {
                this.sourceField = value;
                if (this.sourceField != null)
                {
                    sourceField = sourceField.Replace("/", "\\");
                    tileset xts = FileManager.XmlDeserialize<tileset>(sourceField);
                    image = new mapTilesetImage[xts.image.Length];
                    int count = 0;
                    foreach (tilesetImage ximage in xts.image)
                    {
                        this.image[count] = new mapTilesetImage();
                        this.image[count].source = xts.image[count].source;
                        if (xts.image[count].height != 0)
                        {
                            this.image[count].height = xts.image[count].height;
                        }
                        else
                        {
                            this.image[count].height = xts.tileheight;
                        }

                        if (xts.image[count].width != 0)
                        {
                            this.image[count].width = xts.image[count].width;
                        }
                        else
                        {
                            this.image[count].width = xts.tilewidth;
                        }

                        count++;
                    }

                    this.name = xts.name;
                    this.margin = xts.margin;
                    this.spacing = xts.spacing;
                    this.tileheight = xts.tileheight;
                    this.tilewidth = xts.tilewidth;
                }
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("tileoffset", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public mapTilesetTileOffset[] tileoffset
        {
            get
            {
                return this.tileOffsetField;
            }
            set
            {
                if (this.tileOffsetField != null && this.tileOffsetField.Length > 0)
                {
                    return;
                }
                else
                {
                    this.tileOffsetField = value;
                }
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("image", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public mapTilesetImage[] image
        {
            get
            {
                return this.imageField;
            }
            set
            {
                if (this.imageField != null && this.imageField.Length > 0)
                {
                    return;
                }
                else
                {
                    this.imageField = value;
                }
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int firstgid
        {
            get
            {
                return this.firstgidField;
            }
            set
            {
                this.firstgidField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int tilewidth
        {
            get
            {
                return this.tilewidthField;
            }
            set
            {
                this.tilewidthField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int tileheight
        {
            get
            {
                return this.tileheightField;
            }
            set
            {
                this.tileheightField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int spacing
        {
            get
            {
                return this.spacingField;
            }
            set
            {
                this.spacingField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int margin
        {
            get
            {
                return this.marginField;
            }
            set
            {
                this.marginField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapTilesetImage
    {
        
        private string sourceField;

        private int widthField;

        private int heightField;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string source
        {
            get
            {
                return this.sourceField;
            }
            set
            {
                this.sourceField = value;
                if (this.sourceField != null)
                {
                    this.sourceField = this.sourceField.Replace("/", "\\");
                }
            }
        }

        [XmlIgnore]
        public string sourceFileName
        {
            get
            {
                if (!string.IsNullOrEmpty(source) && source.Contains("\\"))
                {
                    return source.Substring(source.LastIndexOf('\\') + 1);
                }
                else
                {
                    return source;
                }
            }
        }

        [XmlIgnore]
        public string sourceDirectory
        {
            get
            {
                if (!string.IsNullOrEmpty(source) && source.Contains("\\"))
                {
                    return source.Substring(0, source.LastIndexOf('\\'));
                }
                else
                {
                    return source;
                }
            }
        }


        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int width
        {
            get
            {
                return this.widthField;
            }
            set
            {
                this.widthField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int height
        {
            get
            {
                return this.heightField;
            }
            set
            {
                this.heightField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapTilesetTileOffset
    {

        private int xField;

        private int yField;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int x
        {
            get
            {
                return xField;
            }
            set
            {
                xField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int y
        {
            get
            {
                return yField;
            }
            set
            {
                yField = value;
            }
        }
    }        


    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapLayer
    {

        private mapLayerData[] dataField;

        private string nameField;

        private int widthField;

        private int heightField;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("data", Form = System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable = true)]
        public mapLayerData[] data
        {
            get
            {
                return this.dataField;
            }
            set
            {
                this.dataField = value;
                if (dataField != null)
                {
                    foreach (mapLayerData layerData in dataField)
                    {
                        layerData.length = width * height;
                    }
                }
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int width
        {
            get
            {
                return this.widthField;
            }
            set
            {
                this.widthField = value;
                if (this.data != null)
                {
                    foreach (mapLayerData layerData in data)
                    {
                        layerData.length = width * height;
                    }
                }
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int height
        {
            get
            {
                return this.heightField;
            }
            set
            {
                this.heightField = value;
                if (this.data != null)
                {
                    foreach (mapLayerData layerData in data)
                    {
                        layerData.length = width * height;
                    }
                }
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapLayerData
    {

        private string encodingField;

        private string compressionField;

        private string valueField;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string encoding
        {
            get
            {
                return this.encodingField;
            }
            set
            {
                this.encodingField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string compression
        {
            get
            {
                return this.compressionField;
            }
            set
            {
                this.compressionField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string Value
        {
            get
            {
                return this.valueField;
            }
            set
            {
                this.valueField = value;
            }
        }

        private List<uint> _ids = null;
        [XmlIgnore]
        public List<uint> tiles
        {
            get
            {
                if (encodingField != "base64")
                {
                    throw new NotImplementedException("Tiled Map must be saved with base64 encoding");
                }

                if (_ids == null)
                {
                    _ids = new List<uint>(length);
                    // get a stream to the decoded Base64 text
                    Stream data = new MemoryStream(Convert.FromBase64String(Value.Trim()), false);
                    switch (compression)
                    {
                        case "gzip":
                            data = new GZipStream(data, CompressionMode.Decompress, false);
                            break;
                        case "zlib":
                            data = new Ionic.Zlib.ZlibStream(data, Ionic.Zlib.CompressionMode.Decompress, false);
                            break;
                        case null:
                            // Not compressed. Data is already decoded.
                            break;
                        default:
                            throw new InvalidOperationException("Unknown compression: " + compression);
                    }

                    // simply read in all the integers
                    using (data)
                    {
                        using (BinaryReader reader = new BinaryReader(data))
                        {
                            _ids = new List<uint>();
                            for (int i = 0; i < length; i++)
                            {
                                _ids.Add(reader.ReadUInt32());
                            }
                        }
                    }
                }

                return _ids;
            }

        }

        public int length { get; set; }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapObjectgroup
    {

        private mapObjectgroupObject[] objectField;

        private string nameField;

        private int widthField;

        private int heightField;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("object", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public mapObjectgroupObject[] @object
        {
            get
            {
                return this.objectField;
            }
            set
            {
                this.objectField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int width
        {
            get
            {
                return this.widthField;
            }
            set
            {
                this.widthField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int height
        {
            get
            {
                return this.heightField;
            }
            set
            {
                this.heightField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapObjectgroupObject
    {

        private mapObjectgroupObjectPolygon[] polygonField;

        private mapObjectgroupObjectPolyline[] polylineField;

        private int xField;

        private int yField;

        private int widthField;

        private int heightField;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("polygon", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public mapObjectgroupObjectPolygon[] polygon
        {
            get
            {
                return this.polygonField;
            }
            set
            {
                this.polygonField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("polyline", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public mapObjectgroupObjectPolyline[] polyline
        {
            get
            {
                return this.polylineField;
            }
            set
            {
                this.polylineField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int x
        {
            get
            {
                return this.xField;
            }
            set
            {
                this.xField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int y
        {
            get
            {
                return this.yField;
            }
            set
            {
                this.yField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int width
        {
            get
            {
                return this.widthField;
            }
            set
            {
                this.widthField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int height
        {
            get
            {
                return this.heightField;
            }
            set
            {
                this.heightField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapObjectgroupObjectPolygon
    {

        private string pointsField;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string points
        {
            get
            {
                return this.pointsField;
            }
            set
            {
                this.pointsField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    public partial class mapObjectgroupObjectPolyline
    {

        private string pointsField;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string points
        {
            get
            {
                return this.pointsField;
            }
            set
            {
                this.pointsField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public partial class NewDataSet
    {

        private TiledMapSave[] itemsField;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("map")]
        public TiledMapSave[] Items
        {
            get
            {
                return this.itemsField;
            }
            set
            {
                this.itemsField = value;
            }
        }
    }
}