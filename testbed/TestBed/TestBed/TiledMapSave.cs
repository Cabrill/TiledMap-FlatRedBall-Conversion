//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.5448
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Xml.Serialization;
using FlatRedBall;
using System;
using Microsoft.Xna.Framework.Graphics;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using FlatRedBall.IO;
using TestBed;

// 
// This source code was auto-generated by xsd, Version=2.0.50727.3038.
// 


/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
[System.Xml.Serialization.XmlRootAttribute(ElementName = "map", Namespace = "", IsNullable = false)]
public partial class TiledMapSave
{
    enum LessOrGreaterDesired
    {
        Less,
        Greater
    }

    public Scene ToScene(string contentManagerName)
    {
        Scene toReturn = new Scene();

        // TODO: Somehow add all layers separately
        int count = 0;

       

        foreach (int gid in this.layer[0].data[0].tiles)
        {
            Sprite sprite = new Sprite();
            mapTileset tileSet = getTilesetForGid(gid);
            if (tileSet == null)
            {
                ++count;
                continue;
            }

            
            int imageWidth = tileSet.image[0].width;
            int imageHeight = tileSet.image[0].height;
            int tileWidth = tileSet.tilewidth;
            int spacing = tileSet.spacing;
            int tileHeight = tileSet.tileheight;
            int margin = tileSet.margin;

            // TODO: only calculate these once per tileset. Perhaps it can be done in the deserialize method
            int tilesWide = (imageWidth - margin) / (tileWidth + spacing);
            int tilesHigh = (imageHeight - margin) / (tileHeight + spacing);

            sprite.Texture = FlatRedBallServices.Load<Texture2D>(tileSet.image[0].source, contentManagerName);

            // Calculate pixel coordinates in the texture sheet
            int leftPixelCoord = TiledMapSave.calculateXCoordinate(gid - tileSet.firstgid, imageWidth, tileWidth, spacing, margin);
            int topPixelCoord = TiledMapSave.calculateYCoordinate(gid - tileSet.firstgid, imageWidth, tileWidth, tileHeight, spacing, margin);
            int rightPixelCoord = leftPixelCoord + tileWidth;
            int bottomPixelCoord = topPixelCoord + tileHeight;

            // Calculate relative texture coordinates based on pixel coordinates
            sprite.TopTextureCoordinate = GetTextureCoordinate(topPixelCoord, imageHeight, LessOrGreaterDesired.Greater);
            sprite.LeftTextureCoordinate = GetTextureCoordinate(leftPixelCoord, imageWidth, LessOrGreaterDesired.Greater);

            sprite.RightTextureCoordinate = GetTextureCoordinate(rightPixelCoord, imageWidth, LessOrGreaterDesired.Less);
            sprite.BottomTextureCoordinate = GetTextureCoordinate(bottomPixelCoord, imageHeight, LessOrGreaterDesired.Less);

            // Now calculate the world coordinates
            int normalizedX = count % this.width;
            int normalizedY = count / this.width;
            sprite.X = (normalizedX * tileWidth);
            sprite.Y = -(normalizedY * tileHeight);
            ++count;

            sprite.ScaleX = tileWidth / 2;
            sprite.ScaleY = tileHeight / 2;

            toReturn.Sprites.Add(sprite);
        }

        return toReturn;
    }

    private mapTileset getTilesetForGid(int gid)
    {
        // Assuming tilesets are sorted by the firstgid value...
        // Resort with LINQ if not
        for (int i = tileset.Length - 1; i >= 0; --i)
        {
            mapTileset tileSet = tileset[i];
            if (gid >= tileSet.firstgid)
            {
                return tileSet;
            }
        }
        return null;
    }

    private float GetTextureCoordinate(int pixelCoord, int dimension, LessOrGreaterDesired lessOrGreaterDesired)
    {
        float asFloat = pixelCoord / (float)dimension;

        //const float modValue = .000001f;
        const float modValue = .000002f;
        //const float modValue = .00001f;
        if (lessOrGreaterDesired == LessOrGreaterDesired.Greater)
        {
            return asFloat + modValue;
        }
        else
        {
            return asFloat - modValue;
        }
    }

    private static int calculateYCoordinate(int gid, int imageWidth, int tileWidth, int tileHeight, int spacing, int margin)
    {
        int tilesWide = (imageWidth - margin) / (tileWidth + spacing);
        int normalizedy = gid / tilesWide;
        int pixely = normalizedy * (tileHeight + spacing) + margin;

        return pixely;
    }

    private static int calculateXCoordinate(int gid, int imageWidth, int tileWidth, int spacing, int margin)
    {
        int tilesWide = (imageWidth - margin) / (tileWidth + spacing);
        int normalizedX = gid % tilesWide;
        int pixelX = normalizedX * (tileWidth + spacing) + margin;

        return pixelX;
    }

    public static TiledMapSave FromFile(string fileName)
    {
        return FileManager.XmlDeserialize<TiledMapSave>(fileName);
    }

    private mapTileset[] tilesetField;

    private mapLayer[] layerField;

    private string versionField;

    private string orientationField;

    private int widthField;

    private int heightField;

    private int tilewidthField;

    private int tileheightField;

    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("tileset", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
    public mapTileset[] tileset
    {
        get
        {
            return this.tilesetField;
        }
        set
        {
            this.tilesetField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("layer", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
    public mapLayer[] layer
    {
        get
        {
            return this.layerField;
        }
        set
        {
            this.layerField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string version
    {
        get
        {
            return this.versionField;
        }
        set
        {
            this.versionField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string orientation
    {
        get
        {
            return this.orientationField;
        }
        set
        {
            this.orientationField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int width
    {
        get
        {
            return this.widthField;
        }
        set
        {
            this.widthField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int height
    {
        get
        {
            return this.heightField;
        }
        set
        {
            this.heightField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int tilewidth
    {
        get
        {
            return this.tilewidthField;
        }
        set
        {
            this.tilewidthField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int tileheight
    {
        get
        {
            return this.tileheightField;
        }
        set
        {
            this.tileheightField = value;
        }
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
public partial class mapTileset
{

    private mapTilesetImage[] imageField;

    private int firstgidField;

    private string nameField;

    private int tilewidthField;

    private int tileheightField;

    private int spacingField;

    private int marginField;

    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("image", Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
    public mapTilesetImage[] image
    {
        get
        {
            return this.imageField;
        }
        set
        {
            this.imageField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int firstgid
    {
        get
        {
            return this.firstgidField;
        }
        set
        {
            this.firstgidField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string name
    {
        get
        {
            return this.nameField;
        }
        set
        {
            this.nameField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int tilewidth
    {
        get
        {
            return this.tilewidthField;
        }
        set
        {
            this.tilewidthField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int tileheight
    {
        get
        {
            return this.tileheightField;
        }
        set
        {
            this.tileheightField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int spacing
    {
        get
        {
            return this.spacingField;
        }
        set
        {
            this.spacingField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int margin
    {
        get
        {
            return this.marginField;
        }
        set
        {
            this.marginField = value;
        }
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
public partial class mapTilesetImage
{

    private string sourceField;

    private int widthField;

    private int heightField;

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string source
    {
        get
        {
            return this.sourceField;
        }
        set
        {
            this.sourceField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int width
    {
        get
        {
            return this.widthField;
        }
        set
        {
            this.widthField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int height
    {
        get
        {
            return this.heightField;
        }
        set
        {
            this.heightField = value;
        }
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
public partial class mapLayer
{

    private mapLayerData[] dataField;

    private string nameField;

    private int widthField;

    private int heightField;

    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("data", Form = System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable = true)]
    public mapLayerData[] data
    {
        get
        {
            return this.dataField;
        }
        set
        {
            this.dataField = value;
            if (dataField != null)
            {
                foreach (mapLayerData layerData in dataField)
                {
                    layerData.length = width * height;
                }
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string name
    {
        get
        {
            return this.nameField;
        }
        set
        {
            this.nameField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int width
    {
        get
        {
            return this.widthField;
        }
        set
        {
            this.widthField = value;
            if (this.data != null)
            {
                foreach (mapLayerData layerData in data)
                {
                    layerData.length = width * height;
                }
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public int height
    {
        get
        {
            return this.heightField;
        }
        set
        {
            this.heightField = value;
            if (this.data != null)
            {
                foreach (mapLayerData layerData in data)
                {
                    layerData.length = width * height;
                }
            }
        }
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
public partial class mapLayerData
{

    private string encodingField;

    private string compressionField;

    private string valueField;

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string encoding
    {
        get
        {
            return this.encodingField;
        }
        set
        {
            this.encodingField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string compression
    {
        get
        {
            return this.compressionField;
        }
        set
        {
            this.compressionField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTextAttribute()]
    public string Value
    {
        get
        {
            return this.valueField;
        }
        set
        {
            this.valueField = value;
        }
    }

    private List<uint> _ids = null;
    [XmlIgnore]
    public List<uint> tiles
    {
        get
        {
            if (_ids == null)
            {
                _ids = new List<uint>(length);
                // get a stream to the decoded Base64 text
                Stream data = new MemoryStream(Convert.FromBase64String(Value.Trim()), false);
                switch (compression)
                {
                    case "gzip":
                        data = new GZipStream(data, CompressionMode.Decompress, false);
                        break;
                    case "zlib":
                        //data = new Ionic.Zlib.ZlibStream(data, Ionic.Zlib.CompressionMode.Decompress, false)
                        break;
                    default:
                        throw new InvalidOperationException("Unknown compression: " + compression);
                }

                // simply read in all the integers
                using (data)
                {
                    using (BinaryReader reader = new BinaryReader(data))
                    {
                        _ids = new List<uint>();
                        for (int i = 0; i < length; i++)
                        {
                            _ids.Add(reader.ReadUInt32());
                        }
                    }
                }
            }

            return _ids;
        }

    }

    public int length { get; set; }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
[System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
public partial class NewDataSet
{

    private TiledMapSave[] itemsField;

    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("map")]
    public TiledMapSave[] Items
    {
        get
        {
            return this.itemsField;
        }
        set
        {
            this.itemsField = value;
        }
    }
}